# 인덱스의 정의
- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조


# 인덱스의 작동 방식 
- 관계형 데이터베이스에서는 B+Tree구조로 된 index를 사용하여 검색 속도를 향상시킴
# 인덱스를 통한 데이터 검색 과정
1. **쿼리 실행:** 사용자가 쿼리를 실행하면 데이터베이스 엔진은 쿼리에서 지정된 조건을 만족하는 데이터를 찾아야 합니다.
2. **인덱스 선택:** 엔진은 쿼리에서 사용된 컬럼에 인덱스가 있는지 확인합니다. 인덱스가 있으면 엔진은 해당 인덱스를 사용하여 데이터를 검색합니다.
3. **인덱스 탐색:** 엔진은 인덱스를 사용하여 쿼리 조건을 만족하는 데이터의 위치를 찾습니다.
4. **데이터 검색:** 엔진은 인덱스에서 찾은 위치를 사용하여 실제 데이터 페이지에 접근하고 데이터를 검색합니다.
5. **결과 반환:** 엔진은 검색된 데이터를 사용자에게 반환합니다.

**인덱스 사용 시점**

다음과 같은 경우 인덱스를 사용하면 데이터 검색 속도를 크게 향상시킬 수 있습니다.

- **조건 검색:** WHERE 절에서 특정 컬럼 값을 기반으로 데이터를 검색하는 경우
- **정렬:** ORDER BY 절에서 특정 컬럼을 기반으로 데이터를 정렬하는 경우
- **그룹화:** GROUP BY 절에서 특정 컬럼을 기반으로 데이터를 그룹화하는 경우

# 인덱스의 종류

**1. 기본 인덱스(Primary Index)**

- 테이블 내 각 레코드를 고유하게 식별하는 데 사용됩니다.
- NULL 값을 허용하지 않습니다.
- 테이블에 하나만 존재할 수 있습니다.
- 기본 키(Primary Key) 역할을 합니다.
- 데이터 검색 속도를 높이는 데 사용됩니다.

**2. 보조 인덱스(Secondary Index)**

- 기본 인덱스가 아닌 다른 컬럼에 대한 인덱스입니다.
- NULL 값을 허용합니다.
- 테이블에 여러 개 존재할 수 있습니다.
- 특정 컬럼 값을 기반으로 데이터를 빠르게 검색할 수 있도록 합니다.

**3. 유니크 인덱스(Unique Index)**

- 테이블 내 각 레코드의 특정 컬럼 값이 서로 중복되지 않도록 합니다.
- NULL 값을 허용하지 않습니다.
- 테이블에 여러 개 존재할 수 있습니다.
- 데이터의 무결성을 유지하는 데 사용됩니다.

**4. 컴포지트 인덱스(Composite Index)**

- 여러 개의 컬럼을 포함하는 인덱스입니다.
- 여러 컬럼 조합을 기반으로 데이터를 빠르게 검색할 수 있도록 합니다.

**5. 전문 검색 인덱스(Full Text Index)**

- 텍스트 데이터를 검색하는 데 특화된 인덱스입니다.
- LIKE 연산자를 사용하는 쿼리 속도를 높이는 데 사용됩니다.

**6. 클러스터형 인덱스(Clustered Index)**

- 테이블의 데이터를 실제로 저장하는 방식을 결정하는 인덱스입니다.
- 테이블에 하나만 존재할 수 있습니다.
- 데이터 검색 속도와 데이터 삽입/삭제 속도에 영향을 미칩니다.

**7. 비클러스터형 인덱스(Non-Clustered Index)**

- 클러스터형 인덱스가 아닌 인덱스입니다.
- 테이블 데이터와 별도로 저장됩니다.
- 데이터 검색 속도를 높이는 데 사용됩니다.

**클러스터형 인덱스와 비클러스터형 인덱스의 차이**

|구분|클러스터형 인덱스|비클러스터형 인덱스|
|---|---|---|
|데이터 저장 방식|테이블 데이터를 실제로 저장하는 방식을 결정한다.|테이블 데이터와 별도로 저장된다.|
|존재 개수|테이블에 하나만 존재할 수 있다.|테이블에 여러 개 존재할 수 있다.|
|성능 영향|데이터 검색 속도와 데이터 삽입/삭제 속도에 영향을 미친다.|데이터 검색 속도에 영향을 미친다.|

**인덱스 선택 시 고려 사항**

- 쿼리 패턴: 어떤 컬럼이 자주 사용되는지 분석하여 해당 컬럼에 인덱스를 생성합니다.
- 데이터 크기: 테이블 데이터 크기가 클 경우 인덱스 생성에 많은 시간과 공간이 소요될 수 있습니다.
- 성능 요구 사항: 데이터 검색 속도가 중요한 경우 인덱스를 생성하는 것이 유리합니다.

인덱스는 데이터베이스 성능을 최적화하는 데 중요한 역할을 하지만, 무조건 많은 인덱스를 생성하는 것이 좋은 것은 아닙니다. 적절한 인덱스를 생성하고 관리하는 것이 중요합니다.


## 인덱스 생성 전략

**인덱스 생성 전략 수립 시 고려해야 할 사항:**

**1. 어떤 열에 인덱스를 생성해야 하는지 결정하는 기준:**

- **쿼리 패턴 분석:**
    
    - 어떤 컬럼이 WHERE 절, ORDER BY 절, GROUP BY 절 등에서 자주 사용되는지 분석합니다.
    - 자주 사용되는 컬럼에 인덱스를 생성하면 쿼리 실행 속도를 크게 향상시킬 수 있습니다.
- **데이터 특성 분석:**
    
    - 컬럼의 데이터 유형, 중복도, NULL 값 비율 등을 분석합니다.
    - 고유 값이 많은 컬럼, 낮은 중복도를 가진 컬럼, NULL 값이 적은 컬럼에 인덱스를 생성하는 것이 효과적입니다.
- **성능 요구 사항:**
    
    - 특정 쿼리의 실행 속도가 중요한 경우 해당 쿼리에 사용되는 컬럼에 인덱스를 생성합니다.

**2. 인덱스 생성 시 고려해야 할 사항:**

- **데이터의 중복도:**
    
    - 중복도가 높은 컬럼에 인덱스를 생성하면 인덱스 크기가 커지고 관리 부담이 증가할 수 있습니다.
    - 중복도가 높은 컬럼에 인덱스를 생성하는 것은 오히려 성능 저하를 초래할 수 있습니다.
- **쿼리 패턴:**
    
    - 쿼리에서 여러 컬럼을 함께 사용하는 경우 컴포지트 인덱스를 생성하는 것이 효과적입니다.
    - 컴포지트 인덱스는 여러 컬럼 조합을 기반으로 데이터를 빠르게 검색할 수 있도록 합니다.
- **데이터베이스 시스템:**
    
    - 사용하는 데이터베이스 시스템에 따라 인덱스 생성 방식과 최적화 전략이 다를 수 있습니다.
    - 데이터베이스 시스템 문서를 참고하여 최적의 인덱스 전략을 수립합니다.

**3. 추가적인 고려 사항:**

- **인덱스 유지 관리:**
    
    - 인덱스는 생성 후에도 지속적으로 관리해야 합니다.
    - 사용하지 않는 인덱스는 삭제하고, 쿼리 패턴 변화에 따라 인덱스를 추가하거나 삭제해야 합니다.
- **모니터링:**
    
    - 인덱스 사용状況을 모니터링하여 인덱스가 효과적으로 작동하는지 확인해야 합니다.
    - 쿼리 실행 계획을 분석하여 인덱스가 실제로 쿼리 실행에 사용되는지 확인합니다.

**인덱스 생성 전략은 데이터베이스 환경과 요구 사항에 따라 달라질 수 있습니다.** 위에 제시된 기준을 참고하여 상황에 맞는 최적의 인덱스 전략을 수립해야 합니다.


## 인덱스 관리

### 인덱스 유지 관리 방법

인덱스는 데이터베이스 성능 향상에 중요한 역할을 하지만, 지속적인 관리가 필요합니다. 효과적인 인덱스 관리를 통해 성능 저하를 방지하고 데이터베이스 시스템을 최적화할 수 있습니다.

**1. 사용하지 않는 인덱스 삭제:**

- 쿼리에서 사용하지 않는 인덱스는 삭제합니다.
- 사용하지 않는 인덱스는 불필요한 공간을 차지하고 업데이트 작업을 증가시켜 성능 저하를 초래합니다.

**2. 인덱스 조각 모으기:**

- 데이터 삽입/삭제/수정 과정에서 인덱스 조각(fragmentation)이 발생할 수 있습니다.
- 인덱스 조각은 인덱스 효율성을 저하시키고 성능 저하를 초래합니다.
- 정기적으로 인덱스 조각 모으기를 통해 인덱스 효율성을 유지합니다.

**3. 인덱스 통계 업데이트:**

- 데이터 변경에 따라 인덱스 통계가 일치하지 않을 수 있습니다.
- 일치하지 않는 인덱스 통계는 쿼리 실행 계획에 영향을 미쳐 성능 저하를 초래합니다.
- 정기적으로 인덱스 통계를 업데이트하여 쿼리 최적화를 유지합니다.

**4. 쿼리 패턴 분석:**

- 쿼리 패턴 변화에 따라 인덱스 효율성이 변할 수 있습니다.
- 정기적으로 쿼리 패턴을 분석하여 사용되지 않는 인덱스를 삭제하거나 새로운 인덱스를 생성합니다.

**5. 인덱스 모니터링:**

- 인덱스 사용状況을 모니터링하여 인덱스가 효과적으로 작동하는지 확인합니다.
- 쿼리 실행 계획을 분석하여 인덱스가 실제로 쿼리 실행에 사용되는지 확인합니다.

### 인덱스의 오버헤드 및 성능 저하 요인

**1. 인덱스 생성 및 유지 관리 오버헤드:**

- 인덱스 생성 및 유지 관리에는 추가적인 작업이 필요합니다.
- 데이터 삽입/삭제/수정 과정에서 인덱스도 함께 업데이트되어야 하기 때문에 오버헤드가 발생합니다.

**2. 불필요한 인덱스:**

- 사용하지 않는 인덱스는 불필요한 공간을 차지하고 업데이트 작업을 증가시켜 성능 저하를 초래합니다.

**3. 인덱스 조각:**

- 데이터 삽입/삭제/수정 과정에서 인덱스 조각(fragmentation)이 발생할 수 있습니다.
- 인덱스 조각은 인덱스 효율성을 저하시키고 성능 저하를 초래합니다.

**4. 쿼리 실행 계획 문제:**

- 일치하지 않는 인덱스 통계는 쿼리 실행 계획에 영향을 미쳐 성능 저하를 초래합니다.

**5. 과도한 인덱스:**

- 과도한 인덱스는 데이터베이스 시스템에 부담을 주고 성능 저하를 초래합니다.

### 인덱스 사용 시의 주의사항

**1. 적절한 컬럼에만 인덱스 생성:**

- 모든 컬럼에 인덱스를 생성하는 것은 오히려 성능 저하를 초래할 수 있습니다.
- 쿼리에서 자주 사용되는 컬럼에만 인덱스를 생성합니다.

**2. 데이터 특성 고려:**

- 컬럼의 데이터 유형, 중복도, NULL 값 비율 등을 고려하여 인덱스를 생성합니다.
- 고유 값이 많은 컬럼, 낮은 중복도를 가진 컬럼, NULL 값이 적은 컬럼에 인덱스를 생성하는 것이 효과적입니다.

**3. 데이터베이스 시스템 고려:**

- 사용하는 데이터베이스 시스템에 따라 인덱스 생성 방식과 최적화 전략이 다를 수 있습니다.
- 데이터베이스 시스템 문서를 참고하여 최적의 인덱스 전략을 수립합니다.

**4. 지속적인 관리:**

- 인덱스는 생성 후에도 지속적인 관리가 필요합니다.
- 사용하지 않는 인덱스는 삭제하고, 쿼리 패턴 변화에 따라 인덱스