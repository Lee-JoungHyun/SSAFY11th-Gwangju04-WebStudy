## Index

> Index란

- 테이블에 대한 동작(select)의 속도를 높여주는 자료 구조
- 책의 찾아보기와 같이 원하는 내용을 바로 찾을 수 있도록 지원
- 테이블의 데이터 조회 시 동작속도를 높여주는 자료구조
- 데이터의 위치를 빠르게 찾아주는 역할
- 컬럼의 값과 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 둠
- MYI(MySQL Index) 파일에 인덱스 저장

> Index의 문제점

- 불필요한 인덱스를 만들면 DB가 차지하는 공간만 늘어나고 전체 테이블을 찾는 것보다 느려짐
- DB의 공간을 차지하므로 추가적인 공간 필요
- 처음 index를 생성하는데 많은 시간 소요
- 데이터 변경 작업이 자주 일어나는 경우 오히려 성능 저하가 일어날 수 있다.

> Index의 종류 - 클러스터형 인덱스

- 특정 나열된 데이터들을 일정 기준으로 정렬해주는 인덱스
- 클러스터형 인덱스 생성 시 데이터 페이지 전체가 다시 정렬 >> 이미 대용량의 데이터가 입력된 상태라면 클러스터형 인덱스 생성시 심각한 부하가 발생.
- 테이블당 하나만 생성 가능, 어느 열에 클러스터형 인덱스를 생성하는지에 따라 성능이 달라짐
- 보조 인덱스보다 검색 속도는 더 빠르다. 단, 입력/수정/삭제는 더 느림
- MySQL의 경우 Primary Key가 있다면 Primary Key를 클러스터형 인덱스로, 없다면 unique 하면서 Not Null인 컬럼을, 그것도 없으면 임의로 보이지 않는 컬럼을 만들어 클러스터형 인덱스로 지정

> Index의 종류 - 클러스터형 인덱스_보조 인덱스

- 개념적으로 후보키에만 부여 가능한 index.
- 보조 인덱스 생성시 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성
- 데이터가 위치하는 주소값
- 클러스터형 인덱스보다 검색 속도는 느리지만 데이터의 입력/수정/삭제 시 성능 부하가 적음
- 보조 인덱스는 테이블당 여러 개 생성 가능

> 제약 조건에 따른 index 결정

- 특정 테이블에 Primary Key가 존재하면서 Unique Key가 존재할 경우
    - Primary Key로 지정된 컬럼은 Clustered index가 됨
    - Unique Key로 지정된 컬럼들은 Secondary index가 됨
    - Unique Key로 지정된 컬럼이 NULL을 허용하던 허용하지 않던 상관없이 모두 Secondary index가 됨
- 특정 테이블에 Primary Key가 존재하지 않으며 특정 컬럼에 UNIQUE + NOT NULL 제약 조건이 지정될 경우
    - 해당 컬럼은 Clustered index가 됨
    - NOT NULL 조건이 없다면 Secondary index가 됨

> Index 생성 전략

- 인덱스는 열 단위에 생성
- where 절에서 사용되는 열에 생성
- where 절에 사용되는 열이라도 자주 사용해야 가치가 있음
- 데이터 중복도가 높은 열에는 인덱스를 만들어도 효과가 없음
- 외래키를 설정한 열에는 자동으로 외래키 인덱스가 생성됨
- 조인에 자주 사용되는 열에는 인덱스를 생성하는 것이 좋음
- 데이터 변경 작업이 얼마나 자주 일어나는지를 고려해야 함
- 클러스터형 인덱스는 테이블당 하나만 생성할 수 있음
- 사용하지 않는 인덱스는 제거
