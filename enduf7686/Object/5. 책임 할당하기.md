# 5. 책임 할당하기

> 클래스 기반 설계에서 메시지 기반 설계로의 자리바꿈은 우리가 해오던 설계 활동의 전환점이다. 메시지 기반의 설계 관점은 클래스 기반의 설계 관점보다 훨씬 유연한 애플리케이션을 만들 수 있게 해준다. “이 클래스가 필요하다는 점은 알겠는데 이 클래스는 무엇을 해야 하지?”라고 질문하지 않고 “**메시지를 전송해야 하는데 누구에게 전송해야 하지**?”라고 질문하는 것. 설계의 핵심 질문을 이렇게 바꾸는 것이 메시지 기반 설계로 향하는 첫걸음이다.

객체를 가지고 있기 때문에 메시지를 보내는 것이 아니다. **메시지를 전송하기 때문에 객체를 갖게 된 것이다.**
> 

### GRASP 패턴

- General Responsibility Assignment Software Pattern(일반적인 책임 할당을 위한 소프트웨어 패턴)
- 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.

### 정보 전문가 패턴(Information Expert)

- 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 그 책임을 할당하라.
- Information Expert 패턴은 객체가 자율적인 존재여야 한다는 사실을 다시 한번 상기시킨다. 정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있기 때문이다.
- Information Expert 패턴을 따르는 것만으로드 자율성이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아진다.
- 책임을 수행하는 객체가 정보를 알고있다고 해서, **그 정보를 저장하고 있을 필요는 없다**.

### 낮은 결합도 패턴(Low Coupling)

- 각 객체들 간의 상호 의존성을 낮추는 방향으로 책임을 부여하라.

### 높은 응집도 패턴(High Cohesion)

- 각 객체가 밀접하게 연관된 책임들만 가지도록 구성하라.
- 클래스의 응집도를 판단할 수 있는 방법은 다음과 같다.
    - 클래스가 하나 이상의 이유로 변경되어야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라.
    - 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다. 초기화되는 속성의 그룹을 기준으로 클래스를 분리하라.
    - 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. 그룹을 기준으로 클래스를 분리하라.

> 낮은 결합도와 높은 응집도는 모든 설계 과정에서 염두에 둬야 하는 원리다. 다시 말해 설계 결정을 평가할 때 적용할 수 있는 중요한 평가 기준이다. 현재의 책임 할당을 검토하거나 여러 설계 대안들이 있을 때 낮을 결합도와 높은 응집도를 유지할 수 있는 설계를 선택해야 한다.
> 

### 창조자 패턴(Creator)

- 객체 A를 생성해야 할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가? 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라.
    - B가 A 객체를 포함하거나 참조한다.
    - B가 A 객체를 기록한다.
    - B가 A 객체를 긴밀하게 사용한다.
    - B가 A 객체를 초기화하는 데 필요한 데이터를 알고 있다.(이 경우 B는 A에 대한 정보 전문가이다.)
- Creator 패턴은 **이미 존재하는 객체 사이의 관계를 이용**하기 때문에 설계가 낮은 결합도를 유지할 수 있게 한다.

### 다형성 패턴(Polymorphism)

- 객체의 타입에 따라 변하는 로직이 있을 때는 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라.
- 조건에 따른 변화는 프로그램의 기본 논리이다. 프로그램을 if~else 또는 switch~case 등의 조건 논리를 이용해서 설계한다면 새로운 변화가 일어난 경우 조건 논리를 수정해야 한다. 이것은 프로그램을 수정하기 어렵고 변경에 취약하게 만든다.
- 다형성을 이용하여 조건 논리를 구현하면 변화에 쉽게 대응할 수 있다.
- 구현을 공유해야 할 필요가 있다면 추상 클래스를, 구현을 공유할 필요 없이 역할을 대체하는 객체들의 책임만 정의하고 싶다면 인터페이스를 사용하면 된다.

> 역할은 책임의 추상화이다.
> 

### 변경 보호 패턴(Protected Variations)

- 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 **캡슐화**하라.
- 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당해야 한다.

### 도메인 모델을 코드와 분리된 막연한 무엇으로 생각하지 마라

- 많은 사람들이 도메인 모델은 구현과는 무관하다고 생각하지만 이것은 도메인 모델의 개념을 오해한 것에 불과하다.
- 도메인 모델은 도메인을 개념적으로 표현한 것이지만 그 안에 포함된 개념과 관계는 구현의 기반이 되어야 한다. 이것은 **도메인 모델이 구현을 염두에 두고 구조화되는 것이 바람직하다**는 것을 의미한다.
- 설계를 주도하는 것은 변경이다. 변경 또한 도메인 모델의 일부로서 반영되어야 한다. 도메인 모델에는 도메인 안에서 변하는 개념과 이들 사이의 관계가 투영돼 있어야 한다.
- 도메인의 구조가 코드의 구조를 이끌어 내는 것은 자연스러울뿐만 아니라 바람직한 것이다.

### 먼저 구현하고 리팩토링하라

- 설계의 시작부터 객체에 올바른 책임을 부여하는 것은 어려운 일이다.
- 책임과 객체 사이에서 방황할 때 돌파구를 찾기 위해서는 목적한 기능을 수행하는 코드를 먼저 작성한 후 리팩토링하여 설계를 개선하는 것이 좋다.

> 나는 다음과 같은 이유로 짧고, 이해하기 쉬운 이름으로 된 메서드를 좋아한다. 첫째, 메서드가 잘게 나눠져 있을 때 다른 메서드에서 사용될 확률이 높아진다. 둘째, **고수준의 메서드를 볼 때 일련의 주석을 읽는 것 같은 느낌이 들게 할 수 있다.** 또한 메서드가 잘게 나눠져 있을 때 오버라이딩 하는 것도 훨씬 싶다. 작은 메서드는 실제로 이름을 잘 지었을 때만 그 진가가 드러나므로, 이름을 지을 때 주의해야 한다.
>