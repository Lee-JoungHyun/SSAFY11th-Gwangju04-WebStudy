# 1. 객체, 설계

> 모든 소프트웨어 모듈에는 세 가지 목적이 있다. 첫 번째 목적은 실행 중에 제대로 동작하는 것이다. 이것은 모듈의 존재 이유라고 할 수 있다. 두 번째 목적은 변경을 위해 존재하는 것이다. 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다. 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다. 모듈의 세 번째 목적은 코드를 읽는 사람과 의사소통하는 것이다. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다. 읽는 사람과 의사소통할 수 없는 모듈은 개선해야 한다.
> 

### 절차지향 설계

- 프로세스와 데이터를 별도의 모듈의 위치시키는 방식

### 객체지향 설계

- 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식

### 절차지향 설계의 문제점

- 코드를 읽기 힘들다.
    - 동작 방식이 현실 세계에서의 상식과 너무 다르다.
    - 하나의 클래스나 메서드에서 너무 많은 세부사항을 다룬다.
- 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 객체 사이의 결합도가 높아질 수 밖에 없다.
- 객체 사이의 결합도가 높다는 것은 변경에 용이하지 않다는 것을 의미한다.

### 어떻게 해야 설계를 개선할 수 있을까?

- 변경을 어렵게 만드는 것은 **의존성**이다. 해결 방법은 **불필요한** 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다.
- 프로세스를 담당하는 객체에 몰려있던 책임을 각각의 데이터 담당 객체로 이동시켜 **캡슐화**함으로써 객체의 자율성을 높일 수 있다.
- 객체의 자율성을 높이는 방향으로 설계를 개선하는 것은 변경을 용이하게 하고 코드를 읽기 쉽게 만든다.

### 하지만 캡슐화는 만능이 아니다.

- 책임을 이동시키면서 변경 전에는 존재하지 않았던 새로운 의존성이 추가될 수 있다. 의존성의 추가는 높은 결합도를 의미하고, 높은 결합도는 변경하기 어려운 설계를 의미한다.
- 객체의 자율성은 높였지만 전체 설계 관점에서는 결합도가 상승하는 것이다.
- 여기서 알 수 있는 점은 특정 기능의 설계 방식이 한 가지 이상일 수 있다는 것이다. 객체의 자율성과 전체 설계의 결합도 사이의 적절한 타협이 필요한 순간이다.
- **훌륭한 설계는 적절한 트레이드오프의 결과물**이라는 사실을 명심하자. 설계는 균형의 예술이다.

### 객체의 의인화

- 훌륭한 객체 지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하고 상호작용하는 설계를 가리킨다.
- 이것은 우리가 세상을 바라보는 직관과도 일치한다. 이 직관에 따르는 코드는 이해하기 더 쉬운 경향이 있다.
- 그 대상이 실세계에서는 생명이 없는 수동적인 존재라고 하더라도 객체지향의 세계로 넘어오는 순간 그들을 능동적이고 자율적인 생명을 가진 존재로 취급해야 한다.
- 이처럼 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 **객체의 의인화**라고 부른다.

### 설계란 무엇인가

- 설계란 코드를 배치하는 것이다.
- 설계는 코드를 작성하는 것보다 더 높은 차원의 창조적인 행위가 아니다. 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다.

### 훌륭한 객체지향 설계

- 훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 **적절하게** 관리하는 설계이다.
- 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공함으로써 요구 사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높여준다.
- 객체지향 패러다임은 우리가 세상을 바라보는 방식대로 코드를 작성할 수 있게 도와준다.

### 정리

- 객체의 자율성을 높이는 방향으로 설계하여 불필요한 의존성을 줄이자!
- 객체를 의인화하여 능동적이고 자율적인 존재로 설계하자!
- 설계에는 정답이 없다. 훌륭한 설계는 적절한 트레이드오프의 결과물이다.
- 변경하기 쉬운 코드는 읽기도 쉽다.