# 2. 객체지향 프로그래밍

### 협력, 객체, 클래스

- 대부분의 사람들은 객체 지향 프로그램을 작성할 때 가장 먼저 어떤 클래스가 필요한지 고민한다.
- 이것은 객체지향의 본질과는 거리가 멀다. 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.
    - 먼저 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민해야 한다. 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.
    - 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다. 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.
- 훌륭한 협력이 훌륭한 객체를 낳고, 훌륭한 객체가 훌륭한 클래스를 낳는다.

### 도메인 구조를 따르는 프로그램 구조

- 사용자가 문제를 해결하기 위해 프로그램에서 사용하는 분야를 **도메인**이라고 한다.
- 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다.

### 인터페이스와 구현의 분리 원칙

- 객체 지향 패러다임에서는 객체라는 단위 안에 **상태**와 **행동**을 한 덩어리로 묶어 문제 영역의 아이디어를 적절하게 표현할 수 있도록 하였다. 이를 **캡슐화**라고 한다.
- 대부분의 객체지향 프로그래밍 언어들은 상태와 행동을 캡슐화하는 것에서 한 걸음 더 나아가 외부에서의 접근을 통제할 수 있는 **접근 제어**라는 메커니즘을 함께 제공한다. 접근 제어를 통해 외부에서의 간섭을 최소화하고 객체를 자율적인 존재로 만들 수 있다.
- 캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.
    - **퍼블릭 인터페이스**: 외부에서 접근이 가능한 부분
    - **구현**: 외부에서는 접근이 불가능하고 오직 내부에서만 접근 가능한 부분
- 접근 제어 메커니즘을 이용해 클래스의 내부와 외부를 명확하게 분리하면 프로그래머에게 구현의 자유가 생긴다.

### 구현의 자유

- 클래스의 내부와 외부를 명확하게 경계 짓는 것은 **클래스 작성자**와 **클라이언트 프로그래머** 모두에게 유용하다.
- 클라이언트 프로그래머는 내부의 구현은 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다.
- 클래스 작성자는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

> 객체지향의 장점은 객체를 이용해 도메인의 이미를 풍부하게 표현할 수 있다는 것이다. 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현하라. 그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음이다.
> 

### 메시지와 메서드

- 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 **요청**할 수 있고, 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 **응답**한다.
- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 **메시지**를 이용하는 것뿐이다. 메시지를 송신하고 수신하면서 서로 필요한 데이터를 요청하고 응답받는다.
- 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다. 이 때 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드**라고 부른다.
- 메시지와 메서드를 구분하는 것은 매우 중요하다. 이 둘을 구분하는 것에서 부터 **다형성**의 개념이 출발한다.

### 컴파일 시간 의존성과 실행 시간 의존성

- 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다. 다시 말해 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.
- 클래스의 의존성과 실행 시점의 의존성이 다르면 다를 수록 설계가 더 유연해지고 확장 가능성이 더 높아진다.
- 하지만 동시에 코드를 이해하고 디버깅하기는 점점 더 어려워진다.
- 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다. 훌륭한 객체지향 설계를 위해서는 **의존성과 양면성 사이에서 트레이드오프**를 적절하게 이루어야 한다.

### 다형성

- 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
- 다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.
- 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 하고, 이것은 인터페이스가 동일해야 한다는 것을 의미한다.
- 메시지와 메서드를 실행 시점에 연결하는 것을 **동적 바인딩**이라고 하고, 컴파일 시점에 연결하는 것을 **정적 바인딩**이라고 한다.

### 추상화의 힘

- 요구사항의 정책을 높은 수준에서 서술할 수 있다.
    - 추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
    - 이런 특징은 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있게 한다.
- 설계가 좀 더 유연해진다.
    - 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.

> 우리가 작성하는 모든 코드에는 합당한 이유가 있어야한다. 비록 아주 사소한 결정이더라도 트레이트오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다. 고민하고 트레이드오프하라.
> 

### 상속과 합성

- 객체지향 설계에서는 코드를 재사용하기 위해 상속, 합성이라는 기법을 사용한다.
- 상속
    - 캡슐화 위반
    - 설계를 유연하지 못하게 만든다.
- 반면에 합성은 상속이 가지는 두 가지의 문제점을 모두 해결한다.

### 정리

- 캡슐화와 접근 제어 메커니즘을 활용하여 인터페이스와 구현을 분리하자.
- 메시지와 메서드를 구분해야 한다.
- 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것이다.
- 항상 고민하고 트레이드오프하자! 내가 짠 모든 코드에는 합당한 이유가 있어야 한다.