# 42.2 이벤트 루프와 태스크 큐

## 요약

  - 자바스크립트 엔진은 싱글 스레드로 동작하기에, 여러가지 작업을 동시에 처리할 수 없다. 이를 극복하기 위해 **이벤트 루프와 태스크 큐** 라는 것이 존재한다.
  - 먼저, 자바스크립트 엔진(V8 등)은 힙 영역과 콜 스택(호출 스택) 영역으로 나눠진다. 콜 스택은 코드가 최초 실행되면 전역 컨텍스트가 올라간다. 이후 호출되는 함수가 있을 시 콜 스택에 실행 컨텍스트가 생성된다. 호출이 종료되면 실행 컨텍스트가 pop된다.
  - 이벤트 루프는 JS에서 비동기 처리를 위한 메커니즘이고, 태스크 큐(이벤트 큐)는 비동기로 동작하는 콜백함수들을 일시적으로 담아놓는 큐이다.
  - 태스크 큐에 담긴 비동기적 콜백 함수들은 콜 스택이 비워지면, 태스크 큐에서 콜 스택으로 이동한다. 이 이동을 이벤트 루프가 제어하고 관리한다.
  - `setTimeout(콜백함수, 3000)` 함수의 예로 흐름을 한번 느껴보자.
    - 이 함수가 실행(콜스택에 실행 컨텍스트 생성)되면, 브라우저의 Web API가 3초만큼 타이머를 설정(예약)하고 콜백 함수를 임시적으로 저장한다. (브라우저 내부에 이를 위한 메모리가 존재한다.)
    - 3초의 타이머가 종료되면, 브라우저는 콜백 함수를 JS엔진의 **태스크 큐**로 전달한다.
    - 이때, JS 엔진의 콜 스택이 비어있다면(실행되고 있는 함수가 X), 콜백함수는 `태스크 큐 -> 콜 스택` 의 과정에 따라 콜 스택으로 올라가 실행 컨텍스트를 생성하고 실행된다.
    - 하지만, 콜 스택에 현재 실행중인 컨텍스트(함수)가 있다면, 그 과정이 끝나서 콜 스택이 비워질 때까지 태스크 큐에서 대기하게 된다.
    - 이렇게 되면 우리가 설정한 3초라는 시간보다 더 많은 시간이 걸리게 된다. -> `setTimeout` 함수가 정확하지 않은 이유.
    - JS엔진과 브라우저가 병행해서 동작한다. 각각이 주어진 과정을 수행하고 협력해서 비동기 작업을 수행하는 것이다.
<br>


## 본문


자바스크립트의 특징 중 하나는 싱글 스레드로 동작한다는 것이다. 싱글 스레드 방식은 한 번에 하나의 태스크만 처리할 수 있다는 것을 의미한다. 하지만 브라우저가 동작하는 것을 살펴보면 많은 태스크가 동시에 처리되는 것처럼 느껴진다.

그 예로, HTML 요소가 애니메이션 효과를 통해 움직이면서 이벤트를 처리하기도 하고, HTTP 요청을 통해 서버로부터 데이터를 가지고 오면서 렌더링하기도 한다. 이처럼 **자바스크립트의 동시성을 지원하는 것**이 바로 **이벤트 루프(Event Loop)**이다.

구글 V8 자바스크립트 엔진을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분된다.



- **콜 스택(호출 스택)**
    
    소스 코드(전역 코드나 함수 코드 등) 평과 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 바로 콜 스택에 해당한다.
    
    함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행된다. 자바스크립트 엔진은 **단 하나의 콜 스택을 사용**하기 때문에 최상위 실행 컨텍스트(실행 중인 컨텍스트)가 종료되어 콜 스택에서 제거되기 전까지는 다른 어떤 태스크도 실행되지 않는다.
    
- **힙 영역**
    
    힙은 객체가 저장되는 메모리 공간이다. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.
    
    메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야 한다. 객체는 원시 값과는 달리 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간의 크기를 런타임에 결정(동적 할당) 해야 한다. 따라서 객체가 저장되는 메모리 공간인 힙은 구조화 되어 있지 않다는 특징이 있다.


<details>
<summary>실행컨텍스트</summary>
<div markdown="1">

- 실행컨텍스트
    
    실행할 코드에 제공할 환경 정보들을 모아놓은 객체. 어떤 객체/함수가 호출될 때 동일한 환경에 있는 환경 정보들을 모은 실행 컨텍스트를 콜스택에 쌓아올린 후 실행하여 코드의 환경과 순서를 보장한다.
    
    처음 JS코드를 실행하면 (1)번과 같이 전역 컨텍스트(최초 환경)가 콜스택에 담긴다.
    
    브라우저는 `window` , node의 경우 `global` 같은 객체를 사용할 수 있는 이유이다.
    
    ```jsx
    (1) 콜스택엔 전역 컨텍스트를 제외하곤 다른 컨텍스트가 없기에
    		전역 컨텍스트와 관련된 코드를 진행한다.
    (2) 전역 컨텍스트와 관련된 코드를 진행 중 a 함수를 실행하였기에
    		a 함수의 환경 정보들을 수집하여 a 실행 컨텍스트를 생성, 콜스택에 담습니다.
    (3) a 함수 내부에서 b 함수를 실행하였기에 b 함수의 환경 정보들을 수집,
    		실행 컨텍스트를 생성, 콜스택에 담습니다. 이전과 똑같이 콜스택 최상단에
    		b 실행 컨텍스트가 있기에 기존 a 실행 컨텍스트와 관련된 코드의 실행을
    		일시적 중단합니다.
    (4) b 함수가 종료된 후 b 실행 컨텍스트가 콜스택에서 제거됩니다.
    		제거 후 콜스택 최상단에는 a 실행 컨텍스트가 있기에 이전에 중단된 지점부터
    		코드 진행이 재개됩니다.
    (5) a 함수 또한 종료된 후 실행 컨텍스트가 콜스택에서 제거됩니다.
    
    이후, 전역 공간에 실행할 코드가 남아있지 않다면 콜스택에서 전역 컨텍스트 또한
    제거되며 콜스택에 아무것도 남지 않은 상태로 종료됩니다.
    ```
    
    실행 컨텍스트는 크게 3종류로 구분한다.
    
    - 전역 실행 컨텍스트
        - 코드가 실행되면 가장 먼저 생서되는 실행 컨텍스트, 전역 범위를 가짐.
    - 함수 실행 컨텍스트
        - 함수가 호출될 때마다 생성되는 실행 컨텍스트. 함수 내부에서 변수, 매개변수 및 내부 함수들을 포함하며, 해당 함수의 실행이 끝나면 컨텍스트가 제거된다.
    - Eval 함수 실행 컨텍스트
        - eval() 함수가 실행될 때 생성되는 실행 컨텍스트.
    
    실행 컨텍스트는 객체 형태로 관리되며, 변수, 함수 등을 저장하고 관리한다.
    
    실행 컨텍스트 객체는 실행 컨텍스트의 상태와 관련된 정보를 포함하며, 변수 객체, 스코프 체인, this 값 등의 속성을 가진다. 

</div>
</details>


    

JS의 힙 영역-콜스택 사이의 흐름

1. **함수 호출**
    
    함수가 호출되면 해당 함수의 **실행 컨텍스트가 생성**되고, 콜 스택의 최상단에 올라감.
    
2. **함수 실행**
    
    콜스택에 푸시된 함수의 코드가 실행된다. 이 과정에서 함수의 지역 변수, 매개변수 등은 콜스택 내(정확히는 그 컨텍스트 내)에 저장된다.
    
3. **변수 및 객체 생성**
    
    함수 내에서 새로운 변수나 객체가 생성될 경우, 이들은 힙(Heap) 영역에 할당된다. 힙 영역은 동적으로 할당된 메모리를 관리하며, 이들 변수와 객체는 스택에 참조되어 사용된다.
    
4. **함수 반환**
    
    함수가 실행을 마치면, 그 함수의 실행 컨텍스트가 콜 스택에서 팝(pop)되어 제거된다.
    
5. **메모리 해제(GC)**
    
    함수 실행 중 생성된 변수(힙에 저장된)나 객체가 더 이상 필요하지 않다면, 가비지 컬렉트가 해당 메모리를 힙에서 해제한다.
    

콜스택과 힙으로 구성되어 있는 자바스크립트 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다.

비동기 처리에서 소스 코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 **브라우저** 또는 **Node.js**가 담당한다.

예를 들어, 비동기 방식으로 동작하는 `setTimeout` 의 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당하지만, 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저(Node.js)가 담당한다.

이 과정을 위해서 브라우저 환경은 태스크 큐(Task Queue)와 이벤트 루프(Event Loop)를 제공한다.

- 태스크 큐(Task Queue / Event Queue / Callback Queue)
    
    `setTimeout` 이나 `setInterval` 과 같은 **비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역**이다. 태스크 큐와는 별도로 프로미스의 후속 처리 메서드의 콜백함수가 일시적으로 보관되는 마이크로 태스크 큐도 존재한다.
    
- 이벤트 루프(Event Loop)
    
    이벤트 루프는 콜 스택에 현재 실행 중인 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인한다. 
    만약 콜 스택이 비어있고 태스크 큐에 대기 중인 함수가 있다면, 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다. 이때 콜 스택으로 이동한 함수는 실행된다. 즉, 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작한다.
    

```jsx
function foo() {
    console.log('foo');
}

function bar() {
    console.log('bar');
}

setTimeout(foo, 0);
bar();
// bar
// foo
// setTimeout이 0초로 설정되어 있지만 태스크 큐를 거치고 이벤트 루프에 의해서
// 콜스택으로 올라가므로 동기적으로 실행되는 bar보다 느리게 실행된다.
// (0초로 설정해도 실제론 4ms 정도가 소요됨 -> 태스크 큐를 거쳐서 오는 시간)
```

1. 전역 코드가 평가되어 전역 실행 컨텍스트가 생성되고 콜 스택에 푸시된다.
2. 전역 코드가 실행되어 `setTimeout` 함수가 호출된다. 이때 `setTimeout` 함수의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 컨텍스트가 된다. 브라우저의 web api인 타이머 함수도 함수이므로 함수 실행 컨텍스트를 생성한다.
3. `setTimeout` 함수가 실행되면 콜백 함수를 호출 스케줄링하고 종료되어 콜 스택에서 팝된다. 이때 호출 스케줄링, 즉 **타이머 설정과 타이머 만료시 콜백함수를 태스크 큐에 푸시하는 것은 브라우저의 역할**이다.
    - `setTimeout` 함수는 콜스택에서 실행되면, 브라우저에게 콜백함수와 타이머 정보를 넘김. `setTimeout` 함수는 종료되어 콜스택에서 pop됨.
    - 브라우저의 백그라운드 영역(내부 메모리 공간인 웹 API)에서 콜백함수가 대기하고, 브라우저는 Web API를 통해 타이머를 설정(콜백함수 전달 예약) → 스케줄링
    - 타이머가 종료되면 브라우저가 태스크 큐로 콜백함수를 전달함.
    - 이때 JS엔진에서 아직 다른 함수(bar)가 실행중이라면, 실제론 3초보다 시간이 더 걸림. → `setTimeout` 함수가 정확하지 않은 이유. (컴퓨터 성능에도 영향)

비동기 함수인 `setTimeout` 의 콜백 함수는 태스크 큐에 푸시되어 대기하다가 콜 스택이 비게 되면, 다시 말해 전역 코드 및 명시적으로 호출된 함수가 모두 종료하면 비로소 콜 스택에 푸시되어 실행된다.

자바스크립트는 싱글 스레드 방식으로 동작한다. 이때 싱글 스레드 방식으로 동작하는 것은 브라우저가 아니라, 브라우저에 내장된 자바스크립트 엔진이다! 만약 모든 자바스크립트 코드가 자바스크립트 엔진에서 싱글 스레드 방식으로 동작한다면 자바스크립트는 비동기로 동작할 수 없다. 즉, **자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작한다.**

브라우저는 자바스크립트 엔진 외에도 렌더링 엔진과 Web API를 제공한다. Web API는 ECAM Script 사양에 정의된 함수가 아니라 브라우저에서 제공하는 API이며, DOM API와 타이머 함수, HTTP 요청(Ajax)과 같은 비동기 처리를 포함한다. 위 예제에서 살펴봤듯이 브라우저의 Web API인 setTimeout 함수가 호출되면 자바스크립트 엔진의 콜 스택에 푸시되어 실행된다.

하지만, `setTimeout` 함수의 두 가지 기능인 타이머 설정과 타이머가 끝나면 콜백 함수를 태스크 큐에 등록하는 처리는 자바스크립트 엔진이 아니라 브라우저가 실행한다. 엔진과 브라우저의 수행은 병행 처리되며, 엔진과 브라우저가 협력하여 비동기 함수인 setTimeout함수가 실행된다.
